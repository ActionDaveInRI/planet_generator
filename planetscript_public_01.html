<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set content type and character encoding -->
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <!-- Responsive meta tag for mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earthlike Planet with Starfield Background</title>
    
    <!-- Include Three.js (local file with fallback to CDN) -->
    <script src="PlanetScript_a1.5_BRANCH_B_files/three.min.js"
            onerror="this.onerror=null;this.src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';">
    </script>
    <!-- Include Simplex Noise for procedural terrain generation -->
    <script src="PlanetScript_a1.5_BRANCH_B_files/simplex-noise.min.js"
            onerror="this.onerror=null;this.src='https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js';">
    </script>
    
    <style>
      /* Global styles: remove default margins and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Make canvas a block element */
      canvas {
        display: block;
      }
      /* Controls panel styling (positioned top-left) */
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        padding-bottom: 70px; /* extra space for the "Save Preset" button */
        border-radius: 12px;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.4);
        font-family: sans-serif;
        max-width: 320px;
        max-height: calc(100% - 20px);
        overflow-y: auto;
        z-index: 100;
      }
      /* Camera animation controls layout */
      #controls .camera-animation-controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
      }
      /* Each button in camera animation controls takes equal width */
      #controls .camera-animation-controls button {
        flex: 1;
        margin: 0 5px;
      }
      /* Section headings */
      #controls h2, #controls h3 {
        margin: 10px 0 5px;
        text-align: center;
      }
      /* Each control group (label+input) */
      .control-group {
        margin-bottom: 12px;
      }
      .control-group label {
        display: block;
        font-size: 14px;
        margin-bottom: 4px;
      }
      /* Range inputs (sliders) take full width */
      .control-group input[type="range"] {
        width: 100%;
      }
      /* Container for sliders with a center marker */
      .slider-container {
        position: relative;
      }
      /* Center marker style for hue adjuster sliders */
      .slider-marker {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 2px;
        height: 20px;
        pointer-events: none;
      }
      /* Specific marker color (saddle brown) */
      .marker-hue {
        background: #8B4513;
      }
      /* Button styling inside the controls panel */
      #controls button {
        width: 100%;
        padding: 8px;
        font-size: 14px;
        margin-top: 5px;
        cursor: pointer;
      }
      /* Import/export textarea styling */
      #importExportBox {
        width: 100%;
        height: 50px;
        margin-top: 8px;
        font-size: 13px;
      }
      /* Preset overlay: container for preset thumbnails (positioned bottom-right) */
      #presetOverlay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        z-index: 200;
        padding: 5px;
        border-radius: 8px;
      }
      /* Individual preset thumbnail style */
      .presetItem {
        position: relative;
        width: 120px;
        height: 120px;
        border: 1px solid #ccc;
        overflow: hidden;
        cursor: pointer;
        border-radius: 6px;
      }
      /* Ensure preset images cover the container */
      .presetItem img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      /* Delete button style on each preset thumbnail */
      .presetItem button {
        position: absolute;
        top: 2px;
        right: 2px;
        background: rgba(255, 0, 0, 0.8);
        border: none;
        color: white;
        font-size: 12px;
        padding: 2px 4px;
        border-radius: 3px;
        cursor: pointer;
      }
      /* Responsive adjustments for small screens */
      @media (max-width: 600px) {
        #controls {
          max-width: 90%;
          left: 5%;
        }
        #presetOverlay {
          right: 5px;
          bottom: 5px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Controls Panel: contains all UI elements for modifying the planet -->
    <div id="controls">
      <!-- Camera Animation Controls (Orbit, Stop, Flight Tour) -->
      <div class="camera-animation-controls">
        <button id="orbitButton">Orbit</button>
        <button id="stopCameraButton">Stop Animation</button>
        <button id="flightTourButton">Flight Tour</button>
      </div>
      <h2>Planet Controls</h2>
      <!-- Sea Level Slider: Adjusts where the water-land boundary is set -->
      <div class="control-group">
        <label for="seaLevel">Sea Level:</label>
        <input type="range" id="seaLevel" min="-0.1" max="0.1" step="0.01" value="0.00">
      </div>
      <!-- Noise Scale Slider: Changes the frequency of the terrain noise -->
      <div class="control-group">
        <label for="noiseScale">Noise Scale:</label>
        <input type="range" id="noiseScale" min="1" max="10" step="0.1" value="2.5">
      </div>
      <!-- Mountain Height Slider: Controls vertical displacement (terrain roughness) -->
      <div class="control-group">
        <label for="mountainHeight">Mountain Height:</label>
        <input type="range" id="mountainHeight" min="0" max="0.2" step="0.01" value="0.06">
      </div>
      <!-- Temperature Slider: Influences the color gradients on land -->
      <div class="control-group">
        <label for="temperature">Temperature (Colder/Hotter):</label>
        <input type="range" id="temperature" min="-1" max="1" step="0.1" value="0">
      </div>
      <!-- Atmosphere Thickness Slider: Sets the size of the atmospheric layer -->
      <div class="control-group">
        <label for="atmosphereThickness">Atmosphere Thickness:</label>
        <input type="range" id="atmosphereThickness" min="1.01" max="1.5" step="0.01" value="1.33">
      </div>
      <!-- Atmosphere Intensity Slider: Adjusts the opacity and emissiveness of the atmosphere -->
      <div class="control-group">
        <label for="atmosphereIntensity">Atmosphere Intensity:</label>
        <input type="range" id="atmosphereIntensity" min="0" max="1" step="0.1" value="0.2">
      </div>
      <!-- Cloud Opacity Slider: Controls how transparent the clouds are -->
      <div class="control-group">
        <label for="cloudOpacity">Cloud Opacity:</label>
        <input type="range" id="cloudOpacity" min="0" max="1" step="0.1" value="0.1">
      </div>
      <!-- Cloud Noise Scale Slider: Changes the detail level of the cloud noise -->
      <div class="control-group">
        <label for="cloudNoiseScale">Cloud Noise Scale:</label>
        <input type="range" id="cloudNoiseScale" min="1" max="5" step="0.1" value="1.6">
      </div>
      <!-- Size Modifier Slider: Scales the overall size of the planet -->
      <div class="control-group">
        <label for="sizeModifier">Size Modifier:</label>
        <input type="range" id="sizeModifier" min="0.5" max="1.5" step="0.01" value="1.13">
      </div>
      <!-- Hue Adjustment Sliders: Adjust the hue of land, sea, and air -->
      <div class="control-group">
        <label for="landHueAdjustment">Land Hue Adjustment:</label>
        <div class="slider-container">
          <input type="range" id="landHueAdjustment" min="-180" max="180" step="1" value="0">
          <div class="slider-marker marker-hue"></div>
        </div>
      </div>
      <div class="control-group">
        <label for="seaHueAdjustment">Sea Hue Adjustment:</label>
        <div class="slider-container">
          <input type="range" id="seaHueAdjustment" min="-180" max="180" step="1" value="0">
          <div class="slider-marker marker-hue"></div>
        </div>
      </div>
      <div class="control-group">
        <label for="airHueAdjustment">Air Hue Adjustment:</label>
        <div class="slider-container">
          <input type="range" id="airHueAdjustment" min="-180" max="180" step="1" value="0">
          <div class="slider-marker marker-hue"></div>
        </div>
      </div>
      <!-- Rotation Speed Slider: Adjusts how fast the planet rotates -->
      <div class="control-group">
        <label for="rotationSpeed">Rotation Speed:</label>
        <input type="range" id="rotationSpeed" min="0" max="0.01" step="0.0001" value="0.001">
      </div>
      <!-- Standard Buttons for updating, regenerating, resetting, randomizing, exporting, and importing settings -->
      <button id="updateButton">Update</button>
      <button id="regenerateButton">Regenerate Fractal</button>
      <button id="resetHuesButton">Reset Hues</button>
      <button id="randomButton">Random Planet</button>
      <h2>Import/Export</h2>
      <button id="exportButton">Export Settings</button>
      <textarea id="importExportBox" placeholder="Paste your settings here..."></textarea>
      <button id="importButton">Import Settings</button>
      <h2>Presets</h2>
      <button id="savePresetButton">Save Preset</button>
    </div>
    
    <!-- Preset overlay: displays saved planet thumbnails -->
    <div id="presetOverlay"></div>
    
    <script>
      // ----------------------------
      // Utility Functions
      // ----------------------------
  
      /**
       * smoothStep(x, edge0, edge1)
       * Performs a smooth interpolation between 0 and 1 as x moves from edge0 to edge1.
       */
      function smoothStep(x, edge0, edge1) {
        let t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
        return t * t * (3 - 2 * t);
      }
      
      /**
       * createGlowSprite(size, color)
       * Creates a glowing sprite (using a canvas radial gradient) that can be used for effects (e.g., sun glow).
       */
      function createGlowSprite(size, color) {
        // Create a canvas element
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const context = canvas.getContext("2d");
        // Create a radial gradient from the center outward
        const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        context.fillStyle = gradient;
        context.fillRect(0, 0, 128, 128);
        // Create a texture from the canvas and then a sprite using that texture
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({
          map: texture,
          blending: THREE.AdditiveBlending,
          transparent: true
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(size, size, 1);
        return sprite;
      }
      
      // ----------------------------
      // PlanetApp Module
      // Encapsulates all functionality for the 3D planet app.
      // ----------------------------
      const PlanetApp = (() => {
        // Create the scene and add exponential fog for depth effect.
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);
  
        // Create a perspective camera with a 45° field of view.
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  
        // Create the WebGL renderer with antialiasing enabled for smoother edges.
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
  
        // Initialize the SimplexNoise generator for procedural terrain.
        const noise = new SimplexNoise();
  
        // ----------------------------
        // Default Planet Parameters
        // ----------------------------
        let seaLevel = -0.02, noiseScale = 4, mountainHeight = 0.08, temperature = 0.0,
            atmosphereThickness = 1.2, atmosphereIntensity = 0.4, sizeModifier = 1,
            landHueAdjustment = 0, seaHueAdjustment = 0, airHueAdjustment = 0,
            cloudOpacity = 0.4, cloudNoiseScale = 3;
        let rotationSpeed = 0.001;
  
        // Global variables for the planet mesh and other scene objects.
        let sphere, planetGroup, sunLight;
        let seedOffset = 0;
        const presets = [];
  
        // Variables to control camera animation modes: "none", "orbit", or "flight"
        let cameraAnimationMode = "none";
        let cameraAnimationStartTime = 0;
        let orbitConfig = null, flightCurve = null;
        let previousTangent = new THREE.Vector3(0, 0, 1);
  
        // Save original camera position and target for resetting animations.
        const originalCameraPosition = new THREE.Vector3(-1.2, 0, 3);
        const originalCameraTarget = new THREE.Vector3(0, 0, 0);
  
        let updateTimeout = null;
  
        // ----------------------------
        // Initialization Function
        // ----------------------------
        function init() {
          // Set up the camera.
          camera.position.copy(originalCameraPosition);
          camera.lookAt(originalCameraTarget);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          document.body.appendChild(renderer.domElement);
  
          // Add ambient light to the scene.
          scene.add(new THREE.AmbientLight(0x404040, 0.5));
  
          // Set up a directional "sun" light with shadows.
          sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
          sunLight.position.set(-10, 5, 5);
          sunLight.castShadow = true;
          sunLight.shadow.mapSize.width = 2048;
          sunLight.shadow.mapSize.height = 2048;
          sunLight.shadow.bias = -0.0001;
          sunLight.shadow.camera.left = -15;
          sunLight.shadow.camera.right = 15;
          sunLight.shadow.camera.top = 15;
          sunLight.shadow.camera.bottom = -15;
          sunLight.shadow.camera.near = 0.5;
          sunLight.shadow.camera.far = 50;
          scene.add(sunLight);
  
          // Add a glowing sprite at the sun's position.
          const sunGlow = createGlowSprite(10, "rgba(255,255,200,1)");
          sunGlow.position.copy(sunLight.position);
          scene.add(sunGlow);
  
          // Synchronize planet parameters with UI controls, then create the planet.
          updatePlanetParameters();
          createPlanet();
  
          // Create the background starfield.
          createStarfield();
          // Start the animation loop.
          animate();
          // Add UI event listeners.
          addEventListeners();
        }
  
        // ----------------------------
        // Planet Generation
        // ----------------------------
        function createPlanet() {
          // Remove the existing planet group if it exists.
          if (planetGroup) { scene.remove(planetGroup); }
          // Create a high-resolution sphere geometry to form the planet.
          const geometry = new THREE.SphereGeometry(sizeModifier, 2048, 2048);
          const colors = [];
          const position = geometry.attributes.position;
  
          // Loop through each vertex of the sphere to adjust its position and color.
          for (let i = 0; i < position.count; i++) {
            const x = position.getX(i), y = position.getY(i), z = position.getZ(i);
            // Compute noise-based height for terrain displacement.
            const height = noise.noise3D(x * noiseScale + seedOffset, y * noiseScale + seedOffset, z * noiseScale + seedOffset) * mountainHeight;
            // Displace vertex positions based on noise.
            position.setXYZ(i, x * (1 + height), y * (1 + height), z * (1 + height));
  
            // Compute the vertex's latitude for color blending.
            const latitude = Math.asin(y / Math.sqrt(x * x + y * y + z * z));
            const latFactor = Math.abs(latitude) / (Math.PI / 2);
            const gradientWidth = 0.05;
  
            // Define color palettes for different terrains.
            const desertColor    = new THREE.Color(0xc2b280);
            const tropicalColor  = new THREE.Color(0x556b2f);
            const temperateColor = new THREE.Color(0x8f9779);
            const iceColor       = new THREE.Color(0xf5f5f5);
            let baseColor = new THREE.Color();
            const color = new THREE.Color();
  
            // Determine vertex color based on height relative to sea level.
            if (height <= seaLevel) {
              // Water: blend between deep water and shallow water colors.
              let waterBlend = (height - (seaLevel - 0.02)) / 0.02;
              waterBlend = THREE.MathUtils.clamp(waterBlend, 0, 1);
              const shallowWater = new THREE.Color(0x2f4f4f);
              const deepWater    = new THREE.Color(0x1e3f66);
              color.copy(deepWater).lerp(shallowWater, waterBlend);
            } else {
              // Land: use temperature and latitude to choose terrain colors.
              if (temperature >= 0) { // Warmer conditions.
                if (temperature >= 0.98) {
                  // Extremely hot: all desert.
                  color.copy(desertColor);
                } else {
                  let hotFactor = temperature / 0.98;
                  let D0 = 0.25, V0 = 0.50, I0 = 0.75; // Baseline thresholds.
                  let D = THREE.MathUtils.lerp(D0, 1, hotFactor);
                  let V = THREE.MathUtils.lerp(V0, 1, hotFactor);
                  let I = THREE.MathUtils.lerp(I0, 1, hotFactor);
  
                  if (latFactor < D - gradientWidth / 2) {
                    baseColor.copy(desertColor);
                  } else if (latFactor < D + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, D - gradientWidth / 2, D + gradientWidth / 2);
                    baseColor.copy(desertColor).lerp(tropicalColor, tVal);
                  } else if (latFactor < V - gradientWidth / 2) {
                    baseColor.copy(tropicalColor);
                  } else if (latFactor < V + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, V - gradientWidth / 2, V + gradientWidth / 2);
                    baseColor.copy(tropicalColor).lerp(temperateColor, tVal);
                  } else if (latFactor < I - gradientWidth / 2) {
                    baseColor.copy(temperateColor);
                  } else if (latFactor < I + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, I - gradientWidth / 2, I + gradientWidth / 2);
                    baseColor.copy(temperateColor).lerp(iceColor, tVal);
                  } else {
                    baseColor.copy(iceColor);
                  }
                  color.copy(baseColor);
                }
              } else { // Cooler conditions.
                if (temperature <= -0.98) {
                  // Extremely cold: all ice.
                  color.copy(iceColor);
                } else {
                  let coldFactor = -temperature / 0.98;
                  let D0 = 0.25, V0 = 0.50, I0 = 0.75;
                  let D = THREE.MathUtils.lerp(D0, 0, coldFactor);
                  let V = THREE.MathUtils.lerp(V0, 0, coldFactor);
                  let I = THREE.MathUtils.lerp(I0, 0, coldFactor);
  
                  if (latFactor < D - gradientWidth / 2) {
                    baseColor.copy(desertColor);
                  } else if (latFactor < D + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, D - gradientWidth / 2, D + gradientWidth / 2);
                    baseColor.copy(desertColor).lerp(tropicalColor, tVal);
                  } else if (latFactor < V - gradientWidth / 2) {
                    baseColor.copy(tropicalColor);
                  } else if (latFactor < V + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, V - gradientWidth / 2, V + gradientWidth / 2);
                    baseColor.copy(tropicalColor).lerp(temperateColor, tVal);
                  } else if (latFactor < I - gradientWidth / 2) {
                    baseColor.copy(temperateColor);
                  } else if (latFactor < I + gradientWidth / 2) {
                    let tVal = smoothStep(latFactor, I - gradientWidth / 2, I + gradientWidth / 2);
                    baseColor.copy(temperateColor).lerp(iceColor, tVal);
                  } else {
                    baseColor.copy(iceColor);
                  }
                  color.copy(baseColor);
                }
              }
            }
  
            // Apply hue adjustment to the computed color.
            applyHueAdjustment(color, landHueAdjustment);
            colors.push(color.r, color.g, color.b);
          }
  
          // Set the vertex color attribute.
          geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
          geometry.attributes.color.needsUpdate = true;
  
          // Create a standard material that uses vertex colors.
          const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            roughness: 1.0,
            metalness: 0.0,
          });
          // Create the mesh (planet surface) and enable shadow casting/receiving.
          sphere = new THREE.Mesh(geometry, material);
          sphere.castShadow = true;
          sphere.receiveShadow = true;
  
          // Group the planet mesh, atmosphere, and clouds.
          planetGroup = new THREE.Group();
          planetGroup.add(sphere);
  
          // Add atmosphere and cloud layers.
          addAtmosphere();
          createCloudLayers(atmosphereThickness * sizeModifier);
          scene.add(planetGroup);
        }
  
        // ----------------------------
        // Atmosphere Generation
        // ----------------------------
        function addAtmosphere() {
          // Create a sphere slightly larger than the planet for the atmosphere.
          const atmosphereGeometry = new THREE.SphereGeometry(atmosphereThickness * sizeModifier, 2048, 2048);
          const atmosphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x87cefa,
            transparent: true,
            opacity: atmosphereIntensity,
            emissive: 0x1e90ff,
            emissiveIntensity: 0.15,
            side: THREE.BackSide, // Render the inside of the sphere.
          });
          // Adjust atmosphere color based on hue settings.
          applyHueAdjustment(atmosphereMaterial.color, airHueAdjustment);
          const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
          sphere.add(atmosphere);
        }
  
        // ----------------------------
        // Hue Adjustment Utility
        // ----------------------------
        /**
         * applyHueAdjustment(color, hueShift)
         * Adjusts the hue of a THREE.Color by the specified shift (in degrees).
         */
        function applyHueAdjustment(color, hueShift) {
          const hsl = { h: 0, s: 0, l: 0 };
          color.getHSL(hsl);
          hsl.h = (hsl.h + hueShift / 360 + 1) % 1;
          color.setHSL(hsl.h, hsl.s, hsl.l);
        }
  
        // ----------------------------
        // Cloud Layers Generation
        // ----------------------------
        function createCloudLayers(baseRadius) {
          // Create two cloud layers with varying opacity and noise detail.
          for (let i = 0; i < 2; i++) {
            const layerRadius = baseRadius + 0.05 + i * 0.01;
            const layerNoiseScale = cloudNoiseScale * (1 - i * 0.33);
            const layerOpacity = cloudOpacity * (1 - i * 0.25);
            const cloudLayer = createCloudLayer(layerRadius, layerNoiseScale, layerOpacity, airHueAdjustment);
            sphere.add(cloudLayer);
          }
        }
  
        /**
         * createCloudLayer(radius, noiseScaleFactor, opacity, hueAdjustment)
         * Generates a cloud layer mesh using procedural noise for texture.
         */
        function createCloudLayer(radius, noiseScaleFactor, opacity, hueAdjustment) {
          const cloudGeometry = new THREE.SphereGeometry(radius, 2048, 2048);
          const cloudColors = [];
          const positions = cloudGeometry.attributes.position;
          for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            // Generate a noise value to determine cloud density.
            const noiseValue = noise.noise3D(x * noiseScaleFactor, y * noiseScaleFactor, z * noiseScaleFactor) * 0.5 + 0.5;
            const color = new THREE.Color(0xffffff)
              .lerp(new THREE.Color(0x000000), 1 - noiseValue);
            applyHueAdjustment(color, hueAdjustment);
            cloudColors.push(color.r, color.g, color.b);
          }
          cloudGeometry.setAttribute("color", new THREE.Float32BufferAttribute(cloudColors, 3));
          return new THREE.Mesh(cloudGeometry, new THREE.MeshStandardMaterial({
            vertexColors: true,
            transparent: true,
            opacity: opacity,
          }));
        }
  
        // ----------------------------
        // Starfield Background
        // ----------------------------
        function createStarfield() {
          const count = 10000;
          const starGeometry = new THREE.BufferGeometry();
          const positions = [];
          const colors = [];
          // Create random positions and colors for stars.
          for (let i = 0; i < count; i++) {
            positions.push(
              (Math.random() - 0.5) * 2000,
              (Math.random() - 0.5) * 2000,
              (Math.random() - 0.5) * 2000
            );
            colors.push(Math.random(), Math.random(), Math.random());
          }
          starGeometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
          starGeometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
          const starMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true });
          const starMesh = new THREE.Points(starGeometry, starMaterial);
          scene.add(starMesh);
        }
  
        // ----------------------------
        // Flight Tour: Camera Animation Along a Curve
        // ----------------------------
        /**
         * createFlightCurve()
         * Constructs a closed Catmull-Rom spline for the camera flight tour.
         * The flight altitude is set lower (sizeModifier * 0.5) for a closer view.
         */
        function createFlightCurve() {
          const points = [];
          const flightAltitude = sizeModifier * 0.5; // Lower altitude than before
          const flightRadius = sizeModifier * 1.1;
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = flightRadius * Math.cos(angle);
            const z = flightRadius * Math.sin(angle);
            points.push(new THREE.Vector3(x, flightAltitude, z));
          }
          return new THREE.CatmullRomCurve3(points, true);
        }
  
        /**
         * updateFlightTour()
         * Updates the camera's position and orientation as it follows the flight curve.
         * The flight duration is set to 80 seconds for a slower, smoother tour.
         * Here we apply a roll rotation of –90° (i.e. 90° clockwise) around the combined forward axis.
         */
        function updateFlightTour() {
          const elapsed = (performance.now() - cameraAnimationStartTime) / 1000;
          const flightDuration = 80; // Slower tour with longer duration
          const t = (elapsed % flightDuration) / flightDuration;
          const pos = flightCurve.getPointAt(t);
  
          let tangent = flightCurve.getTangentAt(t).clone().normalize();
          if (previousTangent.dot(tangent) < 0) { tangent.negate(); }
          previousTangent.copy(tangent);
  
          // Compute a composite forward vector.
          let toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), pos).normalize();
          let combinedForward = new THREE.Vector3().addVectors(tangent.multiplyScalar(0.8), toCenter.multiplyScalar(0.6)).normalize();
          // Apply a roll rotation of –90° (90° clockwise) around the combined forward axis.
          const rollAngle = THREE.MathUtils.degToRad(-70);
          const rollQuat = new THREE.Quaternion().setFromAxisAngle(combinedForward, rollAngle);
          const desiredUp = new THREE.Vector3(0, 1, 0).applyQuaternion(rollQuat);
  
          // Build a lookAt matrix and extract the corresponding quaternion.
          let m = new THREE.Matrix4();
          m.lookAt(pos, pos.clone().add(combinedForward), desiredUp);
          let desiredQuat = new THREE.Quaternion().setFromRotationMatrix(m);
          camera.quaternion.slerp(desiredQuat, 0.1);
          camera.position.copy(pos);
        }
  
        // ----------------------------
        // Settings Import/Export Functions
        // ----------------------------
        function exportSettings() {
          const settings = {
            seaLevel: parseFloat(document.getElementById("seaLevel").value),
            noiseScale: parseFloat(document.getElementById("noiseScale").value),
            mountainHeight: parseFloat(document.getElementById("mountainHeight").value),
            temperature: parseFloat(document.getElementById("temperature").value),
            atmosphereThickness: parseFloat(document.getElementById("atmosphereThickness").value),
            atmosphereIntensity: parseFloat(document.getElementById("atmosphereIntensity").value),
            cloudOpacity: parseFloat(document.getElementById("cloudOpacity").value),
            cloudNoiseScale: parseFloat(document.getElementById("cloudNoiseScale").value),
            sizeModifier: parseFloat(document.getElementById("sizeModifier").value),
            landHueAdjustment: parseFloat(document.getElementById("landHueAdjustment").value),
            seaHueAdjustment: parseFloat(document.getElementById("seaHueAdjustment").value),
            airHueAdjustment: parseFloat(document.getElementById("airHueAdjustment").value),
            rotationSpeed: parseFloat(document.getElementById("rotationSpeed").value)
          };
          // Encode the settings as a base64 JSON string with markers.
          const json = JSON.stringify(settings);
          const exportString = `PLANET_${btoa(json)}_DATA`;
          document.getElementById("importExportBox").value = exportString;
        }
  
        function importSettings() {
          const importString = document.getElementById("importExportBox").value;
          try {
            if (importString.startsWith("PLANET_") && importString.endsWith("_DATA")) {
              const encoded = importString.slice(7, -5);
              const json = atob(encoded);
              const settings = JSON.parse(json);
              // Update each UI control with the imported settings.
              for (let key in settings) {
                if (document.getElementById(key)) {
                  document.getElementById(key).value = settings[key];
                }
              }
              updatePlanetParameters();
              createPlanet();
            } else {
              throw new Error("Invalid settings format");
            }
          } catch (e) {
            alert("Failed to import settings: " + e.message);
          }
        }
  
        // ----------------------------
        // Thumbnail Generation for Presets
        // ----------------------------
        /**
         * generateThumbnail()
         * Renders the current scene and generates a thumbnail image (cropped and resized).
         */
        function generateThumbnail() {
          return new Promise((resolve, reject) => {
            renderer.render(scene, camera);
            const fullDataURL = renderer.domElement.toDataURL("image/png");
            const img = new Image();
            img.onload = () => {
              const canvasWidth = renderer.domElement.width;
              const canvasHeight = renderer.domElement.height;
              const cropSize = Math.min(canvasWidth, canvasHeight);
              const cropX = (canvasWidth - cropSize) / 2;
              const cropY = (canvasHeight - cropSize) / 2;
              const thumbCanvas = document.createElement("canvas");
              const thumbSize = 120;
              thumbCanvas.width = thumbSize;
              thumbCanvas.height = thumbSize;
              const ctx = thumbCanvas.getContext("2d");
              ctx.drawImage(
                img,
                cropX,
                cropY,
                cropSize,
                cropSize,
                0,
                0,
                thumbSize,
                thumbSize
              );
              resolve(thumbCanvas.toDataURL("image/png"));
            };
            img.onerror = reject;
            img.src = fullDataURL;
          });
        }
  
        // ----------------------------
        // Preset Saving and Loading
        // ----------------------------
        async function savePreset() {
          if (presets.length >= 10) {
            alert("Maximum of 10 presets reached. Delete one to save a new preset.");
            return;
          }
          const presetSettings = {
            seaLevel: parseFloat(document.getElementById("seaLevel").value),
            noiseScale: parseFloat(document.getElementById("noiseScale").value),
            mountainHeight: parseFloat(document.getElementById("mountainHeight").value),
            temperature: parseFloat(document.getElementById("temperature").value),
            atmosphereThickness: parseFloat(document.getElementById("atmosphereThickness").value),
            atmosphereIntensity: parseFloat(document.getElementById("atmosphereIntensity").value),
            cloudOpacity: parseFloat(document.getElementById("cloudOpacity").value),
            cloudNoiseScale: parseFloat(document.getElementById("cloudNoiseScale").value),
            sizeModifier: parseFloat(document.getElementById("sizeModifier").value),
            landHueAdjustment: parseFloat(document.getElementById("landHueAdjustment").value),
            seaHueAdjustment: parseFloat(document.getElementById("seaHueAdjustment").value),
            airHueAdjustment: parseFloat(document.getElementById("airHueAdjustment").value),
            rotationSpeed: parseFloat(document.getElementById("rotationSpeed").value)
          };
          try {
            const thumbnail = await generateThumbnail();
            const preset = { settings: presetSettings, thumbnail: thumbnail };
            presets.push(preset);
            addPresetThumbnail(preset, presets.length - 1);
          } catch (err) {
            alert("Failed to generate thumbnail: " + err);
          }
        }
  
        /**
         * addPresetThumbnail(preset, index)
         * Adds a clickable preset thumbnail to the preset overlay.
         */
        function addPresetThumbnail(preset, index) {
          const container = document.getElementById("presetOverlay");
          const item = document.createElement("div");
          item.className = "presetItem";
          item.dataset.index = index;
          const img = document.createElement("img");
          img.src = preset.thumbnail;
          item.appendChild(img);
          // Create a delete button on the thumbnail.
          const delBtn = document.createElement("button");
          delBtn.textContent = "X";
          delBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            deletePreset(index);
          });
          item.appendChild(delBtn);
          // Clicking the thumbnail loads the preset.
          item.addEventListener("click", () => {
            loadPreset(preset.settings);
          });
          container.appendChild(item);
        }
  
        // Loads a preset by updating the UI controls and regenerating the planet.
        function loadPreset(settings) {
          for (let key in settings) {
            if (document.getElementById(key)) {
              document.getElementById(key).value = settings[key];
            }
          }
          updatePlanetParameters();
          createPlanet();
        }
  
        // Deletes a preset and updates the preset overlay.
        function deletePreset(index) {
          presets.splice(index, 1);
          const container = document.getElementById("presetOverlay");
          container.innerHTML = "";
          presets.forEach((preset, i) => {
            addPresetThumbnail(preset, i);
          });
        }
  
        // ----------------------------
        // Window Resize Handler
        // ----------------------------
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
  
        // ----------------------------
        // Animation Loop
        // ----------------------------
        function animate() {
          requestAnimationFrame(animate);
  
          // Orbit mode: camera circles the planet.
          if (cameraAnimationMode === "orbit") {
            const elapsed = (performance.now() - cameraAnimationStartTime) / 1000;
            const period = 20;
            const angle = (elapsed / period) * 2 * Math.PI * (-1);
            const orbitRadiusX = sizeModifier * 3;
            const orbitRadiusZ = sizeModifier * 2.5;
            const x = orbitRadiusX * Math.cos(angle);
            const z = orbitRadiusZ * Math.sin(angle);
            const inclination = orbitConfig.inclination;
            const y = (z * Math.sin(inclination)) + sizeModifier * 0.5;
            const zRotated = z * Math.cos(inclination);
            camera.position.set(x, y, zRotated);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
          } else if (cameraAnimationMode === "flight") {
            // Flight mode: update camera along the flight curve.
            updateFlightTour();
          }
          // Rotate the planet slowly.
          if (sphere) { sphere.rotation.y += rotationSpeed; }
          renderer.render(scene, camera);
        }
  
        // ----------------------------
        // UI Event Listeners
        // ----------------------------
        function addEventListeners() {
          // Listen to all range input changes.
          document.querySelectorAll("input[type=range]").forEach((input) => {
            input.addEventListener("input", () => {
              if (updateTimeout) clearTimeout(updateTimeout);
              updateTimeout = setTimeout(() => {
                updatePlanetParameters();
                createPlanet();
              }, 50);
            });
          });
          // Button event listeners for various controls.
          document.getElementById("updateButton").addEventListener("click", () => {
            updatePlanetParameters();
            createPlanet();
          });
          document.getElementById("regenerateButton").addEventListener("click", regenerateFractal);
          document.getElementById("resetHuesButton").addEventListener("click", resetHues);
          document.getElementById("randomButton").addEventListener("click", randomizeParameters);
          document.getElementById("exportButton").addEventListener("click", exportSettings);
          document.getElementById("importButton").addEventListener("click", importSettings);
          document.getElementById("savePresetButton").addEventListener("click", savePreset);
  
          // Camera animation control buttons.
          document.getElementById("orbitButton").addEventListener("click", () => {
            cameraAnimationMode = "orbit";
            cameraAnimationStartTime = performance.now();
            const incl = THREE.MathUtils.degToRad(15 + Math.random() * 30);
            orbitConfig = { inclination: incl };
          });
          document.getElementById("flightTourButton").addEventListener("click", () => {
            flightCurve = createFlightCurve();
            previousTangent.copy(flightCurve.getTangentAt(0).normalize());
            cameraAnimationMode = "flight";
            cameraAnimationStartTime = performance.now();
          });
          document.getElementById("stopCameraButton").addEventListener("click", () => {
            cameraAnimationMode = "none";
            camera.position.copy(originalCameraPosition);
            camera.lookAt(originalCameraTarget);
          });
          window.addEventListener("resize", onWindowResize);
        }
  
        // ----------------------------
        // Update Planet Parameters from UI Controls
        // ----------------------------
        function updatePlanetParameters() {
          seaLevel = parseFloat(document.getElementById("seaLevel").value);
          noiseScale = parseFloat(document.getElementById("noiseScale").value);
          mountainHeight = parseFloat(document.getElementById("mountainHeight").value);
          temperature = parseFloat(document.getElementById("temperature").value);
          atmosphereThickness = parseFloat(document.getElementById("atmosphereThickness").value);
          atmosphereIntensity = parseFloat(document.getElementById("atmosphereIntensity").value);
          cloudOpacity = parseFloat(document.getElementById("cloudOpacity").value);
          cloudNoiseScale = parseFloat(document.getElementById("cloudNoiseScale").value);
          sizeModifier = parseFloat(document.getElementById("sizeModifier").value);
          landHueAdjustment = parseFloat(document.getElementById("landHueAdjustment").value);
          seaHueAdjustment = parseFloat(document.getElementById("seaHueAdjustment").value);
          airHueAdjustment = parseFloat(document.getElementById("airHueAdjustment").value);
          rotationSpeed = parseFloat(document.getElementById("rotationSpeed").value);
        }
  
        // Reset hue adjustments to default values.
        function resetHues() {
          landHueAdjustment = 0;
          seaHueAdjustment = 0;
          airHueAdjustment = 0;
          document.getElementById("landHueAdjustment").value = 0;
          document.getElementById("seaHueAdjustment").value = 0;
          document.getElementById("airHueAdjustment").value = 0;
          createPlanet();
        }
  
        // Randomize all planet parameters and regenerate the planet.
        function randomizeParameters() {
          document.getElementById("seaLevel").value = (Math.random() * 0.15 - 0.05).toFixed(2);
          document.getElementById("noiseScale").value = (Math.random() * 6 + 2).toFixed(1);
          document.getElementById("mountainHeight").value = (Math.random() * (0.1 - 0.02) + 0.02).toFixed(2);
          document.getElementById("temperature").value = (Math.random() * 1.6 - 0.8).toFixed(1);
          document.getElementById("atmosphereThickness").value = (Math.random() * (1.45 - 1.1) + 1.1).toFixed(2);
          document.getElementById("atmosphereIntensity").value = (Math.random() * 0.2 + 0.1).toFixed(1);
          document.getElementById("cloudOpacity").value = (Math.random() * 0.3 + 0.1).toFixed(1);
          document.getElementById("cloudNoiseScale").value = (Math.random() * 2 + 1).toFixed(1);
          document.getElementById("sizeModifier").value = (Math.random() * 0.6 + 0.6).toFixed(2);
          document.getElementById("landHueAdjustment").value = Math.floor(Math.random() * 121) - 60;
          document.getElementById("seaHueAdjustment").value = Math.floor(Math.random() * 121) - 60;
          document.getElementById("airHueAdjustment").value = Math.floor(Math.random() * 121);
          updatePlanetParameters();
          createPlanet();
        }
  
        // Regenerate the fractal noise by updating the seed offset.
        function regenerateFractal() {
          seedOffset = Math.random() * 1000;
          createPlanet();
        }
  
        // Expose the init function to start the app.
        return { init };
      })();
  
      // Initialize the app.
      PlanetApp.init();
    </script>
  </body>
</html>
